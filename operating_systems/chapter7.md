#### goroutine与线程的区别

1. 理论上，一个线程与另外一个线程共享内存，并且在创建它们的时候不需要新建新的虚拟内存空间,不需要MMU(内存管理单元)上下文切换，另外，通信比进程更简单，主要因为线程可以共享内存，而进程需要各种模式的IPC，如信号量，消息队列，管道

2. linux不区分线程和进程，它们都称为任务，调用fork()，将创建一个没有共享文件描述符，pid和内存空间的新任务，调用pthread_create(),将创建一个新任务，包含上面所有的共享。

3. 在共享内存中及L1 cache同步在多核上运行的任务所需的数据比在独立内存中运行不同的进程所需的代价更大。

4. 尝试将任务切换成本降到最低，创建新任务的开销比创建新线程的开销大，但*切换*不会

#### 如何改进线程

1. 线程的堆栈大小很大(>1mb),因此消耗大量的内存，创建1000个线程需要1gb的内存

2. 线程恢复需要大量的寄存器

3. 线程设置和拆卸需要调用操作系统的资源(如内存)很慢


#### goroutine优势

1. goroutine只运行在go运行时的虚拟空间中，而不存在于操作系统中，因此需要Go Runtime调度程序来管理它们的生命周期，操作系统看到的只是一个用户级进程并运行多个线程。Goroutine本身由Go RuntimeScheduler管理

2. 

